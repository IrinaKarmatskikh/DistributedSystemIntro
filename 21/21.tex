\newpage
\section {Билет 21. Алгоритмы избрания лидера. Свойства завершения, единственности и согласия. Выборы в кольцевой сети. Выборы на основе протоколов многоадресной передачи. Справедливость.}
\textbf{Задача избрания лидера.}\\
Исходные предположения постановки задачи:
\begin{itemize}
	\item Все процессы, которые объединены в нашей системе, выполняют один и тот же алгоритм (т.е. они однородны).
	\item Сам алгоритм может запускаться одновременно несколькими процессами.
	\item В момент завершения алгоритма ровно один процесс находится в выделенном состоянии лидера. (Ни в какой момент не бывает двух лидеров, а также их может временно не быть вообще.)
\end{itemize}

Примеры задач избрания лидера: 
\begin{itemize}
	\item Выбор ведущего сервера, который будет обрабатывать запросы;
	\item В многоадресовой передаче выбрать процесс, отвечающий за нумерацию сообщений.
\end{itemize}

Варианты задачи определяются из практических соображений, поэтому имеем различные предположения:
\begin{itemize}
	\item Синхронная или асинхронная система;
	\item Знаем ли верхнюю границу на время передачи/обработки сообщений или нет;
	\item Есть ли у процессов их идентификаторы (упорядоченные);
	\item Надёжность сети: пропадают сообщения или нет;
	\item Различные топологии сети.
\end{itemize}

\textbf{Выбор в кольцевых сетях.}\\
Требования:
\begin{enumerate}
	\item Топология сети - кольцо;
	\item У каждого процесса есть сосед справа. Только ему можно передавать сообщения;
	\item У каждого процесса есть уникальный идентификатор и он сам его знает;
	\item Нет никаких потерь;
	\item Канал связи между соседями надёжен и обеспечивает очерёдность доставки FIFO (Сообщение отправленное первым - доставится первым);
	\item Система асинхронна(нет предположений на время работы).
\end{enumerate}

\begin{algorithm}
	\caption{Алгоритм выбора в кольцевых сетях. LeLann(1977).}
	\label{algLeLann}
	\begin{algorithmic}
		\State Идея алгоритма в том, что все процессы сначала хотят составить список всех кандидатов, а потом применить процедуру выбора. Кто победил - лидер. 
		\Require $n$ - количество процессов, Исходно все процессы - спят. $Prev(p), Next(p)$ - номера соседей слева, справа соответственно.
		\Ensure $state_p$\\
		$List_p:=\{p\}_{p=1}^n$ \Comment{Список всех известных процессу идентификаторов.}\\ 
		$state_p \in \{sleep, lost\text{(Проиграл)}, leader, cand\text{(Кандидат)}\}$ \Comment{список состояний.}
		\If{$p$ - инициатор} \Comment{Просыпается один - устраивает выбор лидера.}
		\State $State_p \gets cand$
		\State $send(<message, p>, Next(p))$ \Comment{Посылаем сообщение соседу справа.}
		\State $recv(<message, q> Prev(p))$ \Comment{Ждём от соседа слева сообщения.}
		\While{$q \neq p$} \Comment{Значит в кольце кто-то ещё захотел стать лидером.}
		\State $List_p \gets List_p \cup {q}$
		\State $send(<message, p>, Next(p))$ \Comment{Передаём дальше, чтобы все остальные сформировали тот же список.}
		\State $recv(<message, q> Prev(p))$ \Comment{Ждём от соседа слева сообщения.}
		\State //Как только $q = p$, значит сообщение сделало полный оборот.
		\EndWhile
		\If{$p = \min(List_p)$} \Comment{Любой алгоритм выбора лидера.}
		\State $State_p \gets leader$
		\Else 
		\State $State_p \gets lost$
		\EndIf
		\State В этот момент можно запустить алгоритм оповещения всех о том, кто победил.
		\Else[Не инициаторы] \Comment{Выступает в роли посредника, пересылая сообщение дальше.}
		\While{$True$}
		\State $recv(<message, q>)$ \Comment{Получают сообщение от кого-то.}
		\State $send(<message, q>, Next(p))$ \Comment{Пересылаем следующему.}
		\If{$state_p = sleep$}
		\State $state_p \gets lost$
		\EndIf
		\EndWhile
		\EndIf 
	\end{algorithmic}
\end{algorithm}
\nameref{algLeLann} требует $O(n^2)$ переданных сообщений в худшем случае, когда все - кандидаты, а также $O(n)$ времени, чтобы выбрать лидера в том же случае.

Улучшить время работы - нельзя, так как мы должны всё равно всем отправить сообщения, что выбрали лидера, и получить сообщение о том, что никто другой не является инициатором.

Можно ли уменьшить число сообщений? Да, если получая сообщения, проводить турнир по выбору лидера не глобально после сбора всех кандидатов, а локально, передавая дальше только победителя. См. \nameref{algRoberts}. В этом алгоритме сообщений в среднем $O(n\log n)$. В худшем $O(n^2)$.
\begin{algorithm}
	\caption{Алгоритм выбора в кольцевых сетях. Chang-Roberts(1979).}
	\label{algRoberts}
	\begin{algorithmic}
		\State нам больше не нужен $List_p$. Идея алгоритма в том, что мы выкидываем кандидатов, которые проигрывают сразу.
		\State $state_p \in \{sleep, lost\text{(Проиграл)}, leader, cand\text{(Кандидат)}\}$ \Comment{список состояний.}
		\If{$p$ - инициатор}
		\State $State_p \gets cand$
		\State $send(<message, p>, Next(p))$ \Comment{Посылаем сообщение соседу справа.}
		\While{$state_p \neq leader$} 
		\State $recv(<message, q> Prev(p))$ \Comment{Ждём от соседа слева сообщения.}
		\If{$q = p$}
		$state_p \gets leader$
		\ElsIf{$q < p$} \Comment{Проиграли выбором по меньшему индексу.}
		\If{$state_p = cand$}
		\State $state_p \gets lost$
		\State $send(<message, q>, Next(p))$
		\EndIf
		\EndIf
		\EndWhile
		\Else[Не инициаторы] \Comment{Выступает в роли посредника, пересылая сообщение дальше.}
		\While{$True$}
		\State $recv(<message, q>)$ \Comment{Получают сообщение от кого-то.}
		\State $send(<message, q>, Next(p))$ \Comment{Пересылаем следующему.}
		\If{$state_p = sleep$}
		\State $state_p \gets lost$
		\EndIf
		\EndWhile
		\EndIf 
	\end{algorithmic}
\end{algorithm}

Можно ли сделать всё-таки $O(n\log n)$ в худшем случае? Да, если кольцо имитирует двунаправленное с помощью нескольких разных типов сообщений. (См. \nameref{algPeterson})
\begin{algorithm}
	\caption{Алгоритм выбора в двунаправленных кольцевых сетях. Peterson(1982).}
	\label{algPeterson}
	\begin{algorithmic}
		\State Активные процессы - участвуют в выборах, пассивные передают информацию дальше. 
		\State $state_p \in \{active, passive, lost\text{(Проиграл)}, leader\}$ \Comment{список состояний.}
		\State $state_p \gets passive$
		\State $win_p \gets undefined$ \Comment{Номер победителя.}
		\State $ci_p \gets p$ \Comment{Самое лучшее значение, которое сейчас известно $p$.}
		\State $acn_p$ \Comment{Значение его соседа.}
		\If{$p$ - инициатор}
		\State $State_p \gets active$
		\Else 
		\State $State_p \gets passive$
		\EndIf
		\While{$win_p = undefined$}
		\State $send(<one, ci_p>, Next(p))$ \Comment{Посылаем сообщение типа $one$ соседу справа.}
		\State $recv(<one, q>, Prev(p))$
		\State $acn_p = q$
		\If{$acn_p = ci_p$} \Comment{УСПЕХ!}
		\State $send(<small, ci_p>, Next(p))$ \Comment{Посылаем всем лидера.}
		\State $recv(<small, q>, Prev(p))$ \Comment{Получаем тот же номер, что и отправили. Сделали полный оборот и все признали наше лидерство.}
		\State $win_p \gets acn_p$
		\Else \Comment{Передаём дальше.}
		\State $send(<two, acn_p>, Next(p))$
		\State $recv(<two, q>, Prev(p))$
		\If{$acn_p < ci_p \&\& acn_p < q$} \Comment{Здесь $acn_p$ - полученное на прошлом шаге значение соседа слева.}
		\State $ci_p \gets acn_p$
		\Else 
		\State $state_p \gets passive$ \Comment{Наше $ci_p$ кто-то перебил}
		\EndIf
		\EndIf
		\EndWhile
		\If{$p$ - пассивный} 
		\State // Передаём информацию дальше.
		\EndIf
		\State Когда приходит сообщение типа $small$ мы помечаем, что выбрали лидера.
	\end{algorithmic}
\end{algorithm}

Как происходит выбор лидера, если нет идентификатора процесса? Вся сеть абсолютно однородная.

В этом случае не существует алгоритма детерминированного выбора лидера, так как алгоритм выполняет одни и те же действия и конфигурация, в которой находится система, симметрична.

Если все стали инициаторами выбора одновременно, то все процессы пошлют все свои сообщения одновременно, а затем получат все сообщения одновременно и примут детерминированное решение одновременно. Тогда они могут вообще ничем не отличаться. Всегда можно найти пример начального состояния, когда лидерами станут все, что запрещено в исходной постановке задачи. Поэтому наша цель - нарушить симметрию между процессами.

\textbf{Алгоритмы со случайным выбором.}(Вероятностные)\\
Идея в том, что каждый активный процесс, который хочет участвовать в выборе лидера, назначит себе идентификатор некоторым случайным образом.
Проблема только в том, что два процесса могут получить один и тот же случайный номер. Тогда в условии равенства номера процесса своему можно нарваться на тот же самый номер, пришедший от другого процесса.

Если известно количество  процессов - $n$, то можно передавать в дополнение к сообщению число $n$ и при каждой передаче уменьшать его на $1$. Тогда в конце убедиться, что при совпадении индексов никого не нашлось другого с тем же номером, можно по равенству $n = 1$, так как если $n > 1$, то полный оборот круга не завершился.

Если $n$ не знаем, то можно передавать счётчик соседям, но начинаться он будет с $0$ и каждый будет прибавлять единицу. Тогда наш процесс получит слева свой номер процесса и некоторое значение запущенного счётчика (пусть $n_0$). $n_0$ - это может быть длина кольца, а может быть расстояние до ближайшего процесса, у которого оказался случайно тот же самый номер. Тогда дальше мы отправляем с сообщением второго типа $n_0$ и новый счётчик $k$, начинающийся с $0$, который итерируется в каждом узле круга. Если пришедшее сообщение второго типа $<n_0, k>$ такое, что $n_0 = k$, то мы сделали полный оборот. Единственная проблема, если узлы с одинаковым идентификатором в круге находятся на одинаковом расстоянии друг от друга. (Каждый узел с таким номером, что $n \% R == 0$, где $R$ - расстояние (количество узлов) между узлами с одинаковыми номерами, получит  сообщение, где $<n_0, k>$ таковы, что $n_0 = k$)

Эту проблему нельзя решить. Поэтому мы получаем алгоритм со свойством, что он всегда заканчивает работу, но иногда некорректно, когда несколько процессов выбрали себя в качестве лидеров.
