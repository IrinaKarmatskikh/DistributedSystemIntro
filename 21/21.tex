\newpage
\section{Билет 21. Алгоритмы избрания лидера. Свойства завершения, единственности и согласия. Выборы в кольцевой сети. Выборы на основе протоколов многоадресной передачи. Справедливость.}\label{b21}
\begin{center}
    \textit{\underline{Задача избрания лидера.}}
\end{center}
Исходные предположения постановки задачи:
\begin{itemize}
\item Все процессы, которые объединены в нашей системе, выполняют один и тот же алгоритм (т.е. они однородны).
\item Сам алгоритм может запускаться одновременно несколькими процессами.
\item В момент завершения алгоритма ровно один процесс находится в выделенном состоянии лидера. (Ни в какой момент не бывает двух лидеров, а также их может временно не быть вообще.)
\end{itemize}
Примеры задач избрания лидера: 
\begin{itemize}
\item Выбор ведущего сервера, который будет обрабатывать запросы;
\item В многоадресовой передаче выбрать процесс, отвечающий за нумерацию сообщений.
\end{itemize}
Варианты задачи определяются из практических соображений, поэтому можем рассматривать различные предположения:
\begin{itemize}
\item Синхронная или асинхронная система;\footnote{Знаем ли верхнюю границу на время передачи/обработки сообщений или нет.}
\item Есть ли у процессов их собственные идентификаторы (упорядоченные);
\item Надёжность сети: пропадают сообщения или нет;
\item Различные топологии сети.
\end{itemize}
\begin{center}
    \textit{\underline{Выбор в кольцевых сетях.}}
\end{center}
Требования:
\begin{enumerate}
\item Топология сети - кольцо;
\item У каждого процесса есть сосед справа. Только ему можно передавать сообщения;
\item У каждого процесса есть уникальный идентификатор и он сам его знает;
\item Нет никаких потерь;
\item Канал связи между соседями надёжен и обеспечивает очерёдность доставки FIFO (Сообщение отправленное первым - доставится первым);
\item Система асинхронна(нет предположений на время работы).
\end{enumerate}

\begin{algorithm}
\caption{Алгоритм выбора в кольцевых сетях. LeLann(1977)}
\label{algLeLann}
\begin{algorithmic}
\State Идея алгоритма в том, что все процессы сначала хотят составить список всех кандидатов, а потом применить процедуру выбора. Кто победил - лидер. 
\Require $n$ - количество процессов, исходно все процессы спят. $Prev(p), Next(p)$ - номера соседей слева и справа соответственно.
\Ensure $state_p$\\
$List_p:=\{p\}_{p=1}^n$ \Comment{Список всех известных процессу идентификаторов.}\\ 
$state_p \in \{sleep, lost\text{(Проиграл)}, leader, cand\text{(Кандидат)}\}$ \Comment{список состояний.}
\If{$p$ - инициатор} \Comment{Просыпается один - устраивает выбор лидера.}
    \State $State_p \gets cand$
    \State $send(<message, p>, Next(p))$ \Comment{Посылаем сообщение соседу справа.}
    \State $recv(<message, q>, Prev(p))$ \Comment{Ждём от соседа слева сообщения.}
    \While{$q \neq p$} \Comment{Значит в кольце кто-то ещё захотел стать лидером.}
        \State $List_p \gets List_p \cup {q}$
        \State $send(<message, q>, Next(p))$ \Comment{Передаём дальше, чтобы все остальные}
        \State \Comment{ сформировали тот же самый список кандидатов на выборы.}
        \State $recv(<message, q>, Prev(p))$ \Comment{Ждём от соседа слева сообщения.}
        \State //Как только $q = p$, значит сообщение сделало полный оборот.
    \EndWhile
    \If{$p = \min(List_p)$} \Comment{Какая-нибудь функция выбора лидера (тут $\min$).}
        \State $State_p \gets leader$
    \Else 
        \State $State_p \gets lost$
    \EndIf
    \State В этот момент можно запустить алгоритм оповещения всех о том, кто победил.
\Else[Не инициаторы] \Comment{Выступает в роли посредника, пересылая сообщение дальше.}
    \While{$True$}
        \State $recv(<message, q>, Prev(p))$ \Comment{Получают сообщение от кого-то.}
        \State $send(<message, q>, Next(p))$ \Comment{Пересылаем следующему.}
        \If{$state_p = sleep$}
            \State $state_p \gets lost$
        \EndIf
    \EndWhile
\EndIf 
\end{algorithmic}
\end{algorithm}
\nameref{algLeLann} требует $O(n^2)$ переданных сообщений в худшем случае, когда все процессы являются кандидатами, а также $O(n)$ времени, чтобы выбрать лидера (в том же случае).

Улучшить \textbf{время работы} нельзя, так как мы должны всё равно всем отправить сообщения, что выбрали лидера, и получить сообщение о том, что никто другой не является ининциатором.

Можно ли уменьшить \textbf{число сообщений}? Да, если получая сообщения, проводить турнир по выбору лидера не глобально после сбора всех кандидатов, а локально, передавая дальше только победителя. \nameref{algRoberts} работает по этому принципу и имеет переданных сообщений в среднем $O(n\log n)$. В худшем случае $O(n^2)$.
\begin{algorithm}
\caption{Алгоритм выбора в кольцевых сетях. Chang-Roberts(1979)}
\label{algRoberts}
\begin{algorithmic}
\State Теперь нам больше не нужен список кандидатов $List_p$. Идея алгоритма в том, что мы сразу выкидываем кандидатов, которые проигрывают.
\State $state_p \in \{sleep, lost\text{(Проиграл)}, leader, cand\text{(Кандидат)}\}$ \Comment{список состояний.}
\If{$p$ - инициатор}
    \State $State_p \gets cand$
    \State $send(<message, p>, Next(p))$ \Comment{Посылаем сообщение соседу справа.}
    \While{$state_p \neq leader$} 
        \State $recv(<message, q>, Prev(p))$ \Comment{Ждём от соседа слева сообщения.}
        \If{$q = p$}
            $state_p \gets leader$
        \ElsIf{$q < p$} \Comment{Проиграли выбором по меньшему индексу.}
            \If{$state_p = cand$}
                \State $state_p \gets lost$
                \State $send(<message, q>, Next(p))$
            \EndIf
        \EndIf
    \EndWhile
\Else[Не инициаторы] \Comment{Выступает в роли посредника, пересылая сообщение дальше.}
    \While{$True$}
        \State $recv(<message, q>, Prev(p))$ \Comment{Получают сообщение от кого-то.}
        \State $send(<message, q>, Next(p))$ \Comment{Пересылаем следующему.}
        \If{$state_p = sleep$}
            \State $state_p \gets lost$
        \EndIf
    \EndWhile
\EndIf 
\end{algorithmic}
\end{algorithm}

Можно ли всё-таки сделать $O(n\log n)$ передач в худшем случае? Да, если кольцо имитирует двунаправленное с помощью нескольких разных типов сообщений. Так устроен \nameref{algPeterson}.
\begin{algorithm}
\caption{Алгоритм выбора в «двунаправленных» кольцевых сетях. Peterson(1982)}
\label{algPeterson}
\begin{algorithmic}
\State Активные процессы - участвуют в выборах, пассивные передают информацию. 
\State $state_p \in \{active, passive, lost\text{(Проиграл)}, leader\}$ \Comment{список состояний.}
\State $state_p \gets passive$
\State $win_p \gets undefined$ \Comment{Номер победителя.}
\State $ci_p \gets p$ \Comment{Самое лучшее значение, которое сейчас известно процессу $p$.}
\State $acn_p$ \Comment{Значение от его соседа.}
\If{$p$ - инициатор}
    \State $State_p \gets active$
\Else 
    \State $State_p \gets passive$
\EndIf
\While{$win_p = undefined$}
    \State $send(<one, ci_p>, Next(p))$ \Comment{Посылаем сообщение типа $one$ соседу справа.}
    \State $recv(<one, q>, Prev(p))$
    \State $acn_p = q$
    \If{$acn_p = ci_p$} \Comment{УСПЕХ!}
        \State $send(<small, ci_p>, Next(p))$ \Comment{Посылаем всем лидера.}
        \State $recv(<small, q>, Prev(p))$ \Comment{Получаем тот же номер, что и отправили. Сделали полный оборот и все признали наше лидерство.}
        \State $win_p \gets acn_p$
    \Else \Comment{Передаём дальше.}
        \State $send(<two, acn_p>, Next(p))$
        \State $recv(<two, q>, Prev(p))$
        \If{$acn_p < ci_p \&\& acn_p < q$} \Comment{Здесь $acn_p$ - полученное на прошлом шаге значение соседа слева.}
            \State $ci_p \gets acn_p$
        \Else 
            \State $state_p \gets passive$ \Comment{Наше $ci_p$ кто-то перебил}
        \EndIf
    \EndIf
\EndWhile
\If{$p$ - пассивный} 
    \State // Передаём информацию дальше.
\EndIf
\State Когда приходит сообщение типа $small$ мы помечаем, что выбрали лидера.
\end{algorithmic}
\end{algorithm}

Рассмотрим выбор лидера в том случае, если нет идентификатора процесса. Другими словами, вся сеть абсолютно однородная. Оказывается, что в этом случае не существует\footnote{Доказательство см. на с. 21 книги «Nancy A. Lynch, Boaz Patt-Shamir. DISTRIBUTED ALGORITHMS Lecture Notes for Fall 1992. January, 1993»} детерминированного алгоритма выбора лидера, так как алгоритм выполняет одни и те же действия и конфигурация, в которой находится система, абсолютно симметрична.

Если все стали инициаторами выбора одновременно, то все процессы пошлют все свои сообщения одновременно, а затем получат все сообщения одновременно и примут детерминированное решение одновременно. Тогда они могут вообще ничем не отличаться. Всегда можно найти пример начального состояния, когда лидерами станут все, что запрещено в исходной постановке задачи. Поэтому наша цель - нарушить симметрию между процессами.

\textbf{Алгоритмы со случайным выбором.}(Вероятностные)\\
Идея в том, что каждый активный процесс, который хочет участвовать в выборе лидера, назначет себе идентификатор некоторым случайным образом.
Проблема только в том, что два процесса могут получить один и тот же случайный номер. Тогда в условии равенства номера процесса своему можно нарваться на тот же самый номер, пришедший от другого процесса.

Если известно количество  процессов - $n$, то можно передавать в дополнение к сообщению число $n$ и при каждой передаче уменьшать его на $1$. Тогда в конце достаточно убедиться, что при совпадении собственного идентификатора процесса с полученным от соседа слева не нашлось никого другого с тем же идентификатором. Это возможно сделать с помощью проверки выполнения равенства $n = 1$, так как если полученное $n > 1$, то полный оборот круга не завершился.

Если $n$ неизвестно, то можно передавать счётчик соседям, но начинаться он будет уже с $0$ и каждый передающий процесс будет итеративно прибавлять единицу. Тогда наш процесс получит от соседа слева свой номер процесса и некоторое значение запущенного счётчика (пусть $n_0$). $n_0$ может быть длиной кольца, а может быть расстоянием до ближайшего процесса, который тоже запутил свой счётчик по тому же типу сообщений. Тогда после получения $n_0$ отправляем сообщение второго типа, где будут вместе $n_0$ и новый счётчик $k$, начинающийся с $0$, который аналогично итерируется в каждом узле круга. Если пришедшее сообщение второго типа $<n_0, k_0>$ такое, что $n_0 = k_0$, то мы сделали полный оборот. Единственная проблема, если узлы с одинаковым идентификатором в круге находятся на одинаковом расстоянии друг от друга. (Каждый узел с таким номером, что $n \% R == 0$, где $R$ - расстояние (количество узлов) между узлами с одинаковыми номерами, получит  сообщение, где $<n_0, k_0>$ таковы, что $n_0 = k_0$)

Эту проблему нельзя решить. Поэтому мы получаем алгоритм со свойством, что он всегда заканчивает работу, но иногда некорректно, когда несколько процессов выбрали себя в качестве лидеров.
\begin{center}
    \textit{\underline{Справедливость.}}
\end{center}
Про неё не было рассказано для алгоритмов выбора лидера, но по аналогии с задачей разделения критической секции можно предположить, что требование справедливости - это требование, чтобы лидера не захватывал всегда только один процесс, а обеспечивалось какое-то справедливое или, по-другому, приблизительно равномерное распределение. Добиться этого можно либо с помощью подбора справедливой функции отбора лидера (например если отбирать лидера по функции отбора И условию, что при наличии более одного кандидата процесс $p$ не был лидером в предыдущий раз).
