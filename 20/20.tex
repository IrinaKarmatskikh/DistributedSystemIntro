\newpage
\section {Билет 20. Отношение причинно-следственной зависимости. Метки Лэмпорта, векторные часы.}
Отношение причинно-следственной зависимости - это аналог понятия "Справедливости". Можно сравнивать события и узнавать, какое из них произошло раньше, а какое позже.

У нас имеется в предположении:
\begin{itemize}
\item Сравнимы события в одном процессе (например, локальный счётчик).
\item Сравнимы отправка и получение сообщений. (Отправка сообщения логически предшествует получению этого же самого сообщения.)
\end{itemize}
Хотим реализовать механизм сравнения двух событий в случае, если они сравнимы. (Узнать что произошло раньше, а что позже (транзитивное замыкание описанных выше двух отношений))

Опишем алгоритм:\\
Пусть $n$ - количество процессов. $\forall p = 1, \ldots, n$ заводим свой счётчик $L_p := 0;$ событий.\\
В процессе могут происходить локальные события, которые мы хотим учесть при общем сравнении, поэтому мы их помечаем.\\
Приписываем событию $e$ временную метку $L(e)$ (Leslie Lamport).\\ \\
Когда происходит локальное событие $e$ в процессе с номером $p$:\\
\ \ \ \ $L_p += 1;$\\
\ \ \ \ $L(e) = L_p;$ //Нумеруем локальное событие своим же счётчиком. \\ \\ 
Отправка сообщения $message$ процессу с номером $q$ от процесса с номером $p$:\\
\ \ \ \ $L_p += 1;$\\
\ \ \ \ $send(<message, L_p>, q);$ //Вместе с передаваемыми данными передаём свою метку времени.\\ \\
Получение сообщения $<message, L>$ от процесса с номером $q$ в  процессе с номером $p$:\\ 
\ \ \ \ $L_p = \max\{L,L_p\} + 1;$\\
\ \ \ \ $L(e) = L_p;$ //Получение сообщения тоже может быть учтено как событие $e$. \\

Итого: У всех исходно нулевой счётчик. Каждому событию, которое мы хотим сравнивать, приписываем числовую временную метку. Для локальных событий в $p$ просто увеличиваем локальный счётчик на 1. Отправляя сообщение, локально подписываем факт отправки и затем отправляем свою метку. Получая сообщение, вычисляем максимум временных меток.\\

Пусть событие $e_1$ произошло точно раньше события $e_2$ по нашему заданному отношению причинно-следственной зависимости (либо произошли в одном процессе и $e_1$ раньше $e_2$, либо в разных, но между ними $\exists$ цепочка попарно-сравнимых событий).
Тогда $L(e_1) < L(e_2)$. (По построению будет так)

Замечание: Обратное неверно! \\
(См. рисунок. В момент $t_1$: $2 = L_{p_2} < L_{p_1} = 3$, хотя событие $e_1 < e_2$.)\\
        \includegraphics[width=0.5\textwidth]{20/Comparison_for_labels.jpg}
        
Для выполнения необходимого и достаточного условия ($e_1 < e_2 \Leftrightarrow L(e_1) < L(e_2)$) реализуют механизм под названием "векторные часы". Разница с предыдущим алгоритмом лишь в том, что во всех процессах ведётся учёт временных меток не одного процесса, а целого вектора (массива) временных меток $\bar{L}_p := (L_p^1, \ldots, L_p^n)^T$ всех процессов.\\
Алгоритм:\\
$\forall p = 1, \ldots, n$ заводим свой массив счётчиков $\bar{L}_p := \bar{0};$ событий.\\ \\
Когда происходит локальное событие $e$ в процессе с номером $p$:\\
\ \ \ \ $L_p[p] += 1;$\\
\ \ \ \ $L(e) = L_p;$ //Нумеруем локальное событие своим же счётчиком. \\ \\
Отправка сообщения $message$ процессу с номером $q$ от процесса с номером $p$:\\
\ \ \ \ $L_p[p] += 1;$\\
\ \ \ \ $send(<message, L_p>, q);$ //Вместе с передаваемыми данными передаём свою метку времени.\\ \\
Получение сообщения $<message, L>$ от процесса с номером $q$ в  процессе с номером $p$:\\
\ \ \ \ $L_p[i] = \max\{L[i],L_p[i]\};\ \forall i = 1, \ldots, n.$\\
\ \ \ \ $L_p[p] += 1;$\\
\ \ \ \ $L(e) = L_p;$ //Получение сообщения тоже может быть учтено как событие $e$.\\

Итого: $e_1 < e_2 \Leftrightarrow L(e_1)[i] \leq L(e_2)[i]\ \forall i = 1,\ldots, n$ покоординатно, причём \\$\exists i: L(e_1)[i] < L(e_2)[i]$ строго.\\

Если $\exists i_1, i_2 \in [1,n]: L(e_1)[i_1]< L(e_2)[i_1]$ и при этом же $L(e_1)[i_2] >  L(e_2)[i_2] $, то события $e_1$ и $e_2$ не сравнимы.

Замечание: Multicast, построенный на основе векторных часов - это CO-multicast. (Не можем доставить пришедшее сообщение в процесс до тех пор, пока не получили все сообщения, логически предшествующие тому, что стоит в  очереди.)
