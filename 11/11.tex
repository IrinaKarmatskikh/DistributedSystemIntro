\newpage
\section {Билет 11. Методы шифрования данных.}

Есть два основных метода шифрования 
\begin {itemize}
\item симметричное (т.е. для шифровки и дешифровки используется один и тот же ключ)
\item асимметричное (т.е. для шифровки и дешифровки используются разные ключи)
\end {itemize}

\subsubsection{Симметричное}
Шифр Цезаря\\
\url{https://ru.wikipedia.org/wiki/Шифр_Цезаря} \\
Это вид шифра подстановки, в котором каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите. (т.е. одной букве ставится в соответствие другая) Шифр не устойчив к взлому, так как при передаче больших текстов шифр взламывается частотным анализом. (т.е. анализ частоты вхождения символов в текст) 
Шифр Вернама \\
\url{https://ru.wikipedia.org/wiki/Шифр_Вернама} \\
Пусть сообщение $X$, которое мы хотим передать по открытому каналу связи, представлено в виде вектора из 0 и 1. Выберем другой вектор, такой же длины $K$, будем его называть ключом. Тогда зашифруем сообщение $X$ следующим образом: $X \oplus K = Y$, где $\oplus$ - сложение по модулю два происходит покомпонентно. Сообщение $Y$ - будем называть шифром и его передадим по каналу связи. Этот вид шифрования прост и очень надежен, но если к злоумышленнику попадет сообщение $X$ и $Y$, то можно просто найти ключ $K$ так как $K = X \oplus Y$. Поэтому на практике используют другой подход: пусть хотим передать сообщения $X_1, X_2, X_3 \dots X_n$, пусть выбран какой-то ключ $K_1$, и шифр $Y_1$ получается по правилу $Y_1 = X \oplus K$. Тогда на шаге $i$ ключ $K_i = f (K_{i - 1}, X_i, \dots X_1)$, где $f()$ - некоторая функция. Тогда даже, если будет перехвачен $Y_i$ и $X_i$ и будет получен $K_i$ предыдущие сообщения останутся не расшифрованными, так как они кодировались другими ключами. 
Блочные шифры \\
\url{https://ru.wikipedia.org/wiki/Блочный_шифр} \\
Пусть есть последовательность сообщений одинаковой длинны $X_1, X_2, X_3, \dots$ которую мы хотим передать по открытому каналу связи. Пусть есть последовательность пар $(\sigma_1, K_1), (\sigma_2, K_2), \dots (\sigma_i, K_i) \dots$ где $\sigma$- это перестановка на множестве букв алфавита, $K_i$ - вектор из 0 и 1 одинаковой длины с $X_i$. Тогда ключом мы назовем последовательность пар т.е. $K = ((\sigma_{i_1}, K_{i_1}), (\sigma_{i_2}, K_{i_2}), (\sigma_{i_n}, K_{i_n}))$ и шифрование происходит так: сначала к сообщению $X_1$ применяется перестановка букв $\sigma_{i_1}$, к результату применяется шифр Вернама с ключом $K_{i_1}$ и так далее.

Возникает логичный вопрос, как передать ключ для расшифровки? \\

\subsubsection{Способы передачи ключа}

Первый алгоритм \\
Пусть по открытому каналу связи общаются Алиса (A) и Боб (B) им нужно передать ключ. Пусть есть две функции $f_{A}, f_{B}$ к которым известны обратные $f^{-1}_{A}, f^{-1}_{B}$ и которые обладают свойством $f_{A} (f_{B} (x)) = f_{B} (f_{A} (x))$. Тогда для передачи ключа $k$ от A к B используется следующий алгоритм:
\begin {itemize}
\item A отправляет B сообщение $f_{A} (k)$ 
\item B отправляет A сообщение $f_{B}(f_{A} (k))$
\item A отправляет B сообщение $f^{-1}_{A}(f_{B}(f_{A} (k)))$
\item B применяет к сообщению $f^{-1}_{B}$ и получает $f^{-1}_{B}(f^{-1}_{A}(f_{B}(f_{A} (k)))) = k$
\end {itemize}
В качестве $f_{A}, f_{B}$ - используют функции возведения в степень по модулю

Второй алгоритм (алгоритм Диффи-Хеллмана) \\
\url{https://ru.wikipedia.org/wiki/Протокол_Диффи_—_Хеллмана} \\
Не всегда требуется передать ключ от одного пользователя к другому, иногда достаточно выработать единый. 
\begin {itemize}
\item А придумывает $N$ - модуль по которому будут проводится сравнения, $a, X$ - вычеты по модулю $N$. A отправляет В пару $(X, N, X^{a} (mod N))$
\item B придумывает показатель $b$ и отправляет А $X^{b}$
\item В итоге у А и В формируется одинаковое число $\left( X^{b} \right)^{a}$
\end {itemize}
Надежность этого алгоритма основана на отсутствии быстрого дискретного логарифма.

\subsubsection{Асиметрические алгоритмы (Алгоритмы с открытым ключом)}
В лекциях было упомянуто два подхода: RSA и эллиптические кривые (Но про эллиптические кривые, ничего рассказано не было, поэтому на них забьем). \\
Задача формулируется аналогичным образом, только теперь сообщение X передает Боб. \\
Перед тем как рассказать суть RSA алгоритма вспомним теорему Эйлера. \\
Теорема (Эйлер). Если Числа X и N взаимнопросты, то тогда $X^{\varphi (N)} = 1 (mod N)$ \\
Aлиса берет число $N = pq$, p,q - простые числа. Тогда $\varphi (N) = (p - 1)(q - 1)$. И подбирает число $e$ так, чтобы $(e, \varphi(N)) = 1$. С помощью Алгоритма Евклида ищется $d$ такое, что  $ed = 1 (mod \varphi (N))$. Тогда сам алгоритм выглядит следующим образом:
\begin {itemize}
\item A передает В пару $(N, e)$. e - открытый ключ, d - секретный.
\item B передает сообщение $X^e$
\item A полученное сообщение возводит в степень $d$ т.е. $(X^e)^d = X (mod N)$
\end {itemize}
Ева не может перехватить сообщение $X$ по двум причинам: сложность разложения числа $N$ на простые множители и опять проблема дискретного логарифма.

\subsubsection{Цифровая подпись}
Как Алисе убедить Боба, что она автор сообщения X? Очень просто. Пусть как в предыдущем пункте Алиса выберет $e, d, N$ так, чтобы $ed = 1 (mod \varphi (N))$. Тогда в открытом доступе Алиса публикует пару $(e, N)$ и  $(X, X^d)$. Боб делает проверку: берет $X^d$ из открытого доступа и возводит в степень $e$ и смотрит совпадает ли полученное сообщение с X  т.е. выполнено ли, что $X = (X^d)^e (mod \varphi (N))$





