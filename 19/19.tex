\newpage
\section{Билет 19. Многоадресная передача. Протоколы B-, R-, CO-, ТО-multicast: устойчивость к сбоям, сложность по числу сообщений и времени.}

Ранее рассматриваемые проколы были по типу «точка-точка».
Теперь некоторое множество процессов объединены в группы, и внутри этой группы необходимо организовать передачу сообщений.

\textbf{Задача}: передать сообщения всем участникам (закрытой) группы (с выполнением некоторых дополнительных условий).

Мы знаем всех участников группы. $N$ -- количество процессов в группе. Будем считать, что процессы могут только падать.
Корректный процесс никогда не падает, некорректный -- до какого-то момента работает, падает и не перезапускается.

\textbf{Условие надежности} -- если один корректный процесс сообщение получил, то все остальные корректные процессы сообщение тоже получат.
\bigskip

Протоколы многоадресной передачи:
\begin{itemize}
	\item \nameref{b19:part1} (Basic) %B-multicast
	\item \nameref{b19:part2} (Reliable -- надежность) %R-multicast
	\item \nameref{b19:part3} (First in -- first out, первым пришёл -- первым ушёл) %FIFO-multicast
	\item \nameref{b19:part4} (Total ordering -- глобальный порядок) %TO-multicast
	\item \nameref{b19:part5} (Causal ordering -- отношение причинно-следственной зависимости) %CO-multicast
\end{itemize}

\newpage
\subsection*{B-multicast}\label{b19:part1}

\begin{algorithm}[h!]
\caption{B-multicast. Примитивы.}
\begin{algorithmic}
\algtext*{EndProcedure}
%\let\algorithmicprocedure=\relax \algtext*{EndFor}

\State Процесс $p$ посылает сообщение $m$ в группу $G$
\Procedure{B-multicast}{$m$, $G$}:
	\For{$q$ in $G$}:
		\State send($m$, $q$)
	\EndFor
\EndProcedure
\State
\State Получили в процессе $p$ сообщение $m$ от процесса $q$
\Procedure{B-recieve}{$m$, $q$}:
	\State B-deliver($m$) -- передать сообщение $m$ в свой процесс
\EndProcedure

\end{algorithmic}
\end{algorithm}

\textbf{\textit{B-multicast не гарантирует надежность.}} \newline
\textit{Пример:} Процесс $p$ -- некорректный, отправляет всем сообщения, но ломается. Пусть успел отправить только процессу $q$, который оказался корректным. И кроме $q$ в группе есть ещё корректные процессы, тогда условие надежности не выполнено.

Отправим $N$ сообщений. Сообщение будет доставлено за время одной передачи~\footnote{
В \nameref{b19:part4} увидим, что для отправки 1 сообщения потребуется дополнительный обмен сообщениями.}.


\subsection*{R-multicast}\label{b19:part2}

\begin{algorithm}
\caption{R-multicast. Примитивы.}
\begin{algorithmic}
\algtext*{EndProcedure}

\State Процесс $p$ посылает сообщение $m$ в группу $G$
\Procedure{R-multicast}{$m$, $G$}:
	\State B-multicast($m$, $G$)
\EndProcedure
\State
\State Получили в процессе $p$ сообщение $m$ от процесса $q$
\Procedure{R-recieve}{$m$, $q$}:
	\If{$m$ not in $M$}
		\State R-deliver($m$) -- передать сообщение $m$ в свой процесс
		\State B-multicast($m$, $G$)
		\State $M += m$ -- запоминаем в локальный буфер какие сообщения получили
	\EndIf
\EndProcedure

\end{algorithmic}
\end{algorithm}

Проблемы, описанной для B-multicast, в R-multicast не возникает. \\
Отправим $N^2$ сообщений. Сообщение будет доставлено за время одной передачи.

\newpage
\subsection*{FIFO-multicast}\label{b19:part3}

\begin{algorithm}
\caption{FIFO-multicast. Примитивы.}
\begin{algorithmic}
\algtext*{EndProcedure}

\State В каждом процессе $p$ есть локальный счётчик, который нумерует пакеты.
\State $seq_p = [0, \cdot, 0]$ -- вектор размера $N$ -- порядковые номера сообщения отправителя.
\State
\State Процесс $p$ посылает сообщение $m$ в группу $G$
\Procedure{FIFO-multicast}{$m$, $G$}:
	\State $seq_p[p] += 1$
	\State R-multicast(<$seq_p[p]$, $m$>, $G$)
\EndProcedure
\State
\State Получили в процессе $p$ сообщение $m$ от процесса $q$
\Procedure{FIFO-recieve}{<$seq$, $m$>, $q$}:
	\If{$seq == seq_p[q] + 1$}
		\State // Это следующее сообщение, которое мы хотим получить от процесса $q$
		\State FIFO-deliver($m$) -- передать сообщение $m$ в свой процесс
		\State $seq_p[q] = seq$
		\State Проверить возможность доставки из очереди
	\Else
		\State Поставить в очередь
		\State Проверить возможность доставки
	\EndIf
\EndProcedure

\end{algorithmic}
\end{algorithm}

Сообщения от одного отправителя приходят в том порядке, в котором их послал этот отправитель, то есть от разных отправителей сообщения могут перемешаться.



\subsection*{TO-multicast}\label{b19:part4}

Все процессы должны получать сообщения в одинаковом порядке.

Есть выделенный процесс-нумератор (выбор лидера см. Билет~\ref{b21}), к которому каждый процесс обращается, чтобы получить глобальный порядковый номер своего сообщения.

Процесс $p$ посылает запрос нумератору на получение глобального номера $seq$, и после этого рассылает сообщение всем процессам. Получатели делают очередь -- «глобальный FIFO».

Недостаток: увеличили время на отправку сообщения. Теперь сообщение отправится за 3 передачи (запрос нумератору, ответ нумератора, сама посылка сообщения).

В случае если нумератор упал, мы должны выбрать нового лидера.


\subsection*{CO-multicast}\label{b19:part5}

Хотим задать на множестве событий порядок, события могут быть сравнимы или нет. Сравнимы события в одном процессе -- у нас есть локальные счётчики. Между процессами, мы знаем, что логически отправка сообщения предшествует получению. Подробнее про сравнения см. Билет~\ref{b20}.

Очередь в CO-multicast основана на идеи, что мы не можем пришедшее сообщение доставить в процесс до тех пор, пока мы не получили все сообщения \textbf{логически} предшествующие тому, что стоит в очереди.