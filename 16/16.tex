\newpage
\section{Билет 16. Архитектуры информационных систем: "монолитная"\, клиент-серверная, многоуровневая. Одноранговые системы (peer-to-peer).}

\noindent {\large Компоненты архитектуры распределённой системы:}
\begin{enumerate}
\setlength\itemsep{0.0001em}
\item \textbf{Физическое оборудование и сеть}

Приложение запускается на компьютере определённого производителя, определённого типа памяти и т.д.

\item \textbf{Операционная система}

Устанавливается на физическое оборудование. Одна из задач операционной системы это предоставить единый интерфейс представления оборудования. То есть операционная система скрывает особенности оборудования. Например, если написать программу на Linux, то она будет работать на любом оборудовании с установленной операционной системой Linux. А также, как пример сокрытия предыдущего физического уровня, в Linux есть принцип "всё есть файл"\, то есть любой объект оборудования имеет интерфейс файла в этой системе. 

\item \textbf{Промежуточное ПО (Middleware)}

Поверх операционной системы может работать программное обеспечение промежуточного слоя - Middleware.
Его задача - сокрытие неоднородностей операционных систем и предоставление базовых функций приложениям (удалённый вызов функции, примитивы передачи сообщений, многоадресная передача и т.п.).\\
То есть это набор сервисов, служб, функций которые полезны многим приложениям.

\item \textbf{Приложения и сервисы}

Непосредственно разработанное приложение.
\end{enumerate}

\noindent Цель каждого уровня - максимально скрыть сложность уровня, который был выше.\\
{\large Различные системные архитектуры:}
\begin{enumerate}
\item \textbf{ Монолитное решение}

Всё работает на одном компьютере.

\textit{ Примечание: это не распределённая система.}

\item \textbf{ Клиент-серверная}

Поскольку базы данных как правило используется для совместной работы нескольких пользователей, она обычно вынесена на отдельный сервер. 
То есть существует программа клиент и программа сервер, а также какой-то протокол их общения, желательно открытый.

Базы данных различных разработчиков практически всегда отличаются, и взаимозаменяемости (открытости) на уровне протоколов почти всегда нет, поэтому она достигается за счёт стандартизации запросов (SQL).

\item \textbf{ Клиент-серверная с посредниками (proxy-сервер)}

Есть промежуточные сервера, которые со стороны клиента выглядят так же, как основной, но такой сервер ничего не делает, а просто перенаправляет запросы.\\
Иногда proxy-сервер может оптимизировать доступ к каналам связи, а именно закэшировать какие-то данные, которые часто запрашиваются.\\
Или же на proxy-сервере можно решать какие-то вопросы безопасности. Например, запрет прямого доступа к главному серверу, то есть на главный сервер можно заходить только через proxy-сервер, на котором происходит проверка политики безопасности.

\item \textbf{ Многоуровневая} может быть двух типов:
\begin{itemize}
\item
Многосерверная. При такой архитектуре сервис предоставляется совокупностью вычислительных процессов (серверов). Например, репликация, которая реализована в виде нескольких общающихся процессов, но для клиента выглядят одним.\\

\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{16/MultiSerrver.pdf}
\caption{}
\label{multi_server}
\end{figure}

Например, на Рис. \ref{multi_server} изображён единый сервис с тремя процессами, которые общаются между собой. "клиент 1"\ обратился в "процесс 1"\ , а "клиент 2"\ - в "процесс 3"\ , но при этом для них не должна быть заметна разница в работе с сервисом.

По большому счёту такая система - это клиент-сервер.

\item
Сервера приложений. В этой архитектуре может быть много серверов и при этом один сервер может быть клиентом другого сервера.
Например, подход MVC (Model-View-Controller): клиент <--> сервер <--> база данных.

MVC - схема разделения данных приложения и управляющей логики на три отдельных компонента: модель (хранение данных), представление данных и контроллер (обработка) — таким образом, что модификация каждого компонента может осуществляться независимо.

\begin{figure}[H]
\centering
\includegraphics[scale=0.57]{16/Model-View-Controller.pdf}
\caption{}
\label{application_server}
\end{figure}

К примеру, на Рис. \ref{application_server} представлена система, в которой модель - база данных, представление данных - клиент, а контроллер - сервер приложений.\\
База данных выполняет только операции с данными (SQL запросы). Сервер приложений выполняет всю бизнес-логику. Он также может содержать некий объект, который распределяет запросы на процессы, которые их выполняют и, при необходимости, обращаются к базе данных.
Клиент обычно не делает содержательной работы и отвечает только за ввод данных и отображение результатов (к примеру, веб-браузер).

\end{itemize}

\item \textbf{ Одноранговая}

Вообще никаких серверов не выделяется, нет ни главного процесса, ни клиента, все участники равноправны (например torrent).

\end{enumerate}



















